<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choreographer - Proactive Flow Engine Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .add-robot-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
        }
        
        .add-robot-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }
        
        .add-robot-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .pause-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
        }
        
        .pause-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 152, 0, 0.3);
        }
        
        .pause-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .reset-btn {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }
        
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(244, 67, 54, 0.3);
        }

        .no-go-zone-btn {
            background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
            color: white;
        }
        
        .no-go-zone-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(156, 39, 176, 0.3);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .metric {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-label {
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }
        
        .canvas-container {
            text-align: center;
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            position: relative;
        }
        
        .info {
            margin-top: 20px;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        
        .info h3 {
            margin-top: 0;
            color: #1976d2;
        }
        
        .info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info li {
            margin-bottom: 8px;
            color: #555;
        }
        
        .demo-instructions {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
        }
        
        .demo-instructions h4 {
            margin-top: 0;
            color: #f57c00;
        }
        
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }
        
        .status-running {
            background: #4CAF50;
        }
        
        .status-paused {
            background: #ff9800;
        }
        
        .status-stopped {
            background: #f44336;
        }
        
        .status-finished {
            background: #9C27B0;
        }
        
        .fleet-limit {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            color: #c62828;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè≠ Choreographer - Proactive Flow Engine</h1>
        <p class="subtitle">Intelligent Warehouse Fleet Management with Congestion-Aware Pathfinding</p>
        
        <div class="controls">
            <button id="addRobotBtn" class="add-robot-btn">Add Robot (0/10)</button>
            <button id="pauseBtn" class="pause-btn" disabled>Pause</button>
            <button id="resetBtn" class="reset-btn">Reset</button>
            <button id="noGoZoneBtn" class="no-go-zone-btn">Toggle No-Go Zone</button>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <span class="metric-label">Robot Count</span>
                <span class="metric-value" id="robotCount">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Mission Time</span>
                <span class="metric-value" id="timeValue">0s</span>
            </div>
            <div class="metric">
                <span class="metric-label">Total Distance</span>
                <span class="metric-value" id="distanceValue">0px</span>
            </div>
            <div class="metric">
                <span class="metric-label">Collision Avoidances</span>
                <span class="metric-value" id="collisionValue">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Path Deviations</span>
                <span class="metric-value" id="deviationValue">0</span>
            </div>
            <div class="metric">
                <span class="metric-label">Efficiency Score</span>
                <span class="metric-value" id="efficiencyValue">100%</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <div id="statusIndicator" class="status-indicator status-stopped">Stopped</div>
            <div id="canvas-container"></div>
        </div>
        
        <div class="info">
            <h3>üéØ Proactive Flow Engine Demo</h3>
            <p>This simulation demonstrates intelligent warehouse logistics with congestion-aware pathfinding and dynamic collision avoidance.</p>
            
            <div class="demo-instructions">
                <h4>üöÄ Demo Instructions:</h4>
                <ol>
                    <li><strong>Add Robots:</strong> Scale the fleet (max 10) and watch intelligent pathfinding</li>
                    <li><strong>Observe Congestion:</strong> See robots proactively avoid crowded routes</li>
                    <li><strong>Optimize Layout:</strong> Drag inventory racks to create better pathways</li>
                    <li><strong>Toggle No-Go Zone:</strong> See how removing restrictions improves flow</li>
                    <li><strong>Pause & Analyze:</strong> Use pause to study bottlenecks and plan optimizations</li>
                </ol>
            </div>
            
            <h4>üéÆ Interactive Features:</h4>
            <ul>
                <li><strong>Fleet Scaling:</strong> Add robots up to 10 to test congestion limits</li>
                <li><strong>Proactive Pathfinding:</strong> Robots avoid congested routes before collisions occur</li>
                <li><strong>Draggable Inventory Racks:</strong> Optimize warehouse layout in real-time</li>
                <li><strong>Persistent Path Visualization:</strong> See original vs. adapted routes</li>
                <li><strong>No-Go Zone Management:</strong> Toggle restrictions to demonstrate flow optimization</li>
            </ul>
            
            <h4>üé® Visual Indicators:</h4>
            <ul>
                <li><strong>Blue circles:</strong> Active robots (numbered)</li>
                <li><strong>Red circles:</strong> Robots avoiding collisions</li>
                <li><strong>Green circles:</strong> Completed missions</li>
                <li><strong>Gray shelves:</strong> Inventory racks (drag to optimize)</li>
                <li><strong>Green dots:</strong> Pickup points</li>
                <li><strong>Blue squares:</strong> Dropoff stations</li>
                <li><strong>Dotted blue lines:</strong> Original planned paths</li>
                <li><strong>Solid green lines:</strong> Traveled paths</li>
                <li><strong>Orange lines:</strong> Collision avoidance deviations</li>
                <li><strong>Red zone:</strong> No-go zone (toggleable)</li>
            </ul>
            
            <div class="fleet-limit">
                <strong>Fleet Limit:</strong> Maximum 10 robots to maintain realistic warehouse constraints
            </div>
        </div>
    </div>

    <script>
        // Simulation state
        let simulationState = 'stopped'; // 'stopped', 'running', 'paused'
        let robots = [];
        let obstacles = [];
        let pickupPoints = [];
        let dropoffPoints = [];
        let nextRobotId = 1;
        let draggedObstacle = { index: null, offset: { x: 0, y: 0 } };
        let noGoZone = { x: 400, y: 200, width: 100, height: 100, isActive: true };
        
        let startTime = 0;
        let pausedTime = 0;
        let collisionAvoidances = 0;
        let pathDeviations = 0;
        const MAX_ROBOTS = 10;

        // Generate 20 smaller obstacles for dense shelving grid
        function generateObstacles() {
            const obstacles = [];
            const obstacleSize = 40;
            const spacing = 60;
            
            for (let i = 0; i < 20; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                obstacles.push({
                    x: 100 + col * spacing,
                    y: 100 + row * spacing,
                    width: obstacleSize,
                    height: obstacleSize,
                    id: `obstacle_${i}`,
                    dragging: false
                });
            }
            return obstacles;
        }

        // Generate 15 pickup points near obstacles
        function generatePickupPoints() {
            const points = [];
            for (let i = 0; i < 15; i++) {
                points.push({
                    x: 50 + (i % 3) * 300 + Math.random() * 50,
                    y: 50 + Math.floor(i / 3) * 150 + Math.random() * 50
                });
            }
            return points;
        }

        // Generate 3 dropoff points clustered on one side
        function generateDropoffPoints() {
            return [
                { x: 750, y: 100 },
                { x: 750, y: 300 },
                { x: 750, y: 500 }
            ];
        }

        // Proactive Flow Engine - Congestion-aware pathfinding
        function findPath(start, end, obstacles, allRobots = []) {
            const startVec = createVector(start.x, start.y);
            const endVec = createVector(end.x, end.y);
            
            // Check if direct path is clear
            if (isPathClear(startVec, endVec, obstacles)) {
                const directPath = [startVec, endVec];
                const directPenalty = calculateCongestionPenalty(directPath, allRobots);
                
                if (directPenalty < 0.3) {
                    return directPath;
                }
            }
            
            // Generate alternative paths and choose the one with lowest congestion penalty
            const alternativePaths = generateAlternativePaths(startVec, endVec, obstacles);
            
            if (alternativePaths.length === 0) {
                return [startVec, endVec];
            }
            
            // Evaluate each path and choose the best one
            let bestPath = alternativePaths[0];
            let bestScore = Infinity;
            
            for (let path of alternativePaths) {
                const congestionPenalty = calculateCongestionPenalty(path, allRobots);
                const pathLength = calculatePathLength(path);
                const totalScore = congestionPenalty * 100 + pathLength * 0.1;
                
                if (totalScore < bestScore) {
                    bestScore = totalScore;
                    bestPath = path;
                }
            }
            
            return bestPath;
        }

        // Calculate congestion penalty for a given path
        function calculateCongestionPenalty(path, allRobots) {
            let penalty = 0;
            
            for (let robot of allRobots) {
                if (!robot.originalPath || robot.originalPath.length === 0) continue;
                
                for (let i = 0; i < path.length - 1; i++) {
                    const segmentStart = path[i];
                    const segmentEnd = path[i + 1];
                    
                    for (let j = 0; j < robot.originalPath.length - 1; j++) {
                        const robotSegmentStart = robot.originalPath[j];
                        const robotSegmentEnd = robot.originalPath[j + 1];
                        
                        const distance = getSegmentDistance(segmentStart, segmentEnd, robotSegmentStart, robotSegmentEnd);
                        
                        if (distance < 50) {
                            penalty += (50 - distance) / 50;
                        }
                    }
                }
            }
            
            return Math.min(penalty, 1.0);
        }

        // Calculate distance between two line segments
        function getSegmentDistance(p1, p2, p3, p4) {
            const mid1 = createVector((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
            const mid2 = createVector((p3.x + p4.x) / 2, (p3.y + p4.y) / 2);
            return dist(mid1.x, mid1.y, mid2.x, mid2.y);
        }

        // Calculate total length of a path
        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                length += dist(path[i].x, path[i].y, path[i + 1].x, path[i + 1].y);
            }
            return length;
        }

        // Generate alternative paths around obstacles
        function generateAlternativePaths(start, end, obstacles) {
            const paths = [];
            const strategies = ['right', 'left', 'top', 'bottom'];
            
            for (let strategy of strategies) {
                const path = createStrategyPath(start, end, obstacles, strategy);
                if (path && isPathClear(start, path[1], obstacles)) {
                    paths.push(path);
                }
            }
            
            return paths;
        }

        // Create a path using a specific strategy
        function createStrategyPath(start, end, obstacles, strategy) {
            let blockingObstacle = null;
            for (let obstacle of obstacles) {
                if (lineIntersectsRect(start, end, obstacle)) {
                    blockingObstacle = obstacle;
                    break;
                }
            }
            
            if (!blockingObstacle) {
                return [start, end];
            }
            
            const { x, y, width, height } = blockingObstacle;
            const margin = 25;
            
            let waypoint1, waypoint2;
            
            switch (strategy) {
                case 'right':
                    waypoint1 = createVector(x + width + margin, start.y);
                    waypoint2 = createVector(x + width + margin, end.y);
                    break;
                case 'left':
                    waypoint1 = createVector(x - margin, start.y);
                    waypoint2 = createVector(x - margin, end.y);
                    break;
                case 'top':
                    waypoint1 = createVector(start.x, y - margin);
                    waypoint2 = createVector(end.x, y - margin);
                    break;
                case 'bottom':
                    waypoint1 = createVector(start.x, y + height + margin);
                    waypoint2 = createVector(end.x, y + height + margin);
                    break;
            }
            
            if (isPathClear(start, waypoint1, obstacles) && 
                isPathClear(waypoint1, waypoint2, obstacles) && 
                isPathClear(waypoint2, end, obstacles)) {
                return [start, waypoint1, waypoint2, end];
            }
            
            return null;
        }

        // Check if a straight line path is clear of obstacles
        function isPathClear(start, end, obstacles) {
            for (let obstacle of obstacles) {
                if (lineIntersectsRect(start, end, obstacle)) {
                    return false;
                }
            }
            if (noGoZone.isActive && lineIntersectsRect(start, end, noGoZone)) {
                return false;
            }
            return true;
        }

        // Check if a line intersects with a rectangle
        function lineIntersectsRect(start, end, rect) {
            const { x, y, width, height } = rect;
            const edges = [
                { start: createVector(x, y), end: createVector(x + width, y) },
                { start: createVector(x + width, y), end: createVector(x + width, y + height) },
                { start: createVector(x + width, y + height), end: createVector(x, y + height) },
                { start: createVector(x, y + height), end: createVector(x, y) }
            ];
            
            for (let edge of edges) {
                if (lineIntersectsLine(start, end, edge.start, edge.end)) {
                    return true;
                }
            }
            return false;
        }

        // Check if two line segments intersect
        function lineIntersectsLine(p1, p2, p3, p4) {
            const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(denom) < 0.0001) return false;
            
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        // Robot class with intelligent behavior
        class Robot {
            constructor(id, mission, allRobots = []) {
                this.id = id;
                this.mission = mission;
                this.position = createVector(mission.start.x, mission.start.y);
                this.originalPath = [];
                this.currentPath = [];
                this.traveledPath = [];
                this.speed = 1.5;
                this.pathIndex = 0;
                this.totalDistance = 0;
                this.radius = 8;
                this.reachedDestination = false;
                this.isAvoidingCollision = false;
                this.avoidanceStartTime = 0;
                this.hasDeviated = false;
                
                // Calculate initial path with congestion awareness
                this.originalPath = findPath(mission.start, mission.end, obstacles, allRobots);
                this.currentPath = [...this.originalPath];
                this.traveledPath = [this.position.copy()];
            }

            update(allRobots, obstacles) {
                if (this.reachedDestination || this.currentPath.length === 0) {
                    return;
                }

                // Check for collision avoidance first (primary behavior)
                this.checkForCollisionAvoidance(allRobots);

                // If avoiding collision, slow down
                if (this.isAvoidingCollision) {
                    this.speed = 0.5;
                } else {
                    this.speed = 1.5;
                }

                if (this.pathIndex >= this.currentPath.length) {
                    this.reachedDestination = true;
                    return;
                }

                const target = this.currentPath[this.pathIndex];
                const direction = p5.Vector.sub(target, this.position);
                const distance = direction.mag();

                if (distance < this.speed) {
                    this.position.set(target);
                    this.traveledPath.push(this.position.copy());
                    this.pathIndex++;
                } else {
                    direction.normalize();
                    direction.mult(this.speed);
                    const previousPosition = this.position.copy();
                    this.position.add(direction);
                    
                    this.traveledPath.push(this.position.copy());
                    this.totalDistance += p5.Vector.dist(previousPosition, this.position);
                }
            }

            checkForCollisionAvoidance(allRobots) {
                let needsAvoidance = false;
                
                for (let otherRobot of allRobots) {
                    if (otherRobot.id === this.id) continue;
                    
                    const distance = p5.Vector.dist(this.position, otherRobot.position);
                    const collisionRadius = this.radius + otherRobot.radius + 30;
                    
                    if (distance < collisionRadius) {
                        needsAvoidance = true;
                        break;
                    }
                }
                
                if (needsAvoidance && !this.isAvoidingCollision) {
                    this.isAvoidingCollision = true;
                    this.avoidanceStartTime = millis();
                    collisionAvoidances++;
                    this.createAvoidancePath();
                } else if (!needsAvoidance && this.isAvoidingCollision) {
                    this.isAvoidingCollision = false;
                    this.returnToOriginalPath();
                }
            }

            createAvoidancePath() {
                if (!this.hasDeviated) {
                    this.hasDeviated = true;
                    pathDeviations++;
                }
                
                const currentPos = this.position.copy();
                const avoidanceOffset = 40;
                const angle = Math.random() * Math.PI * 2;
                const avoidancePoint = createVector(
                    currentPos.x + Math.cos(angle) * avoidanceOffset,
                    currentPos.y + Math.sin(angle) * avoidanceOffset
                );
                
                let closestOriginalIndex = this.pathIndex;
                for (let i = this.pathIndex; i < this.originalPath.length; i++) {
                    if (p5.Vector.dist(this.position, this.originalPath[i]) > 80) {
                        closestOriginalIndex = i;
                        break;
                    }
                }
                
                this.currentPath = [
                    currentPos,
                    avoidancePoint,
                    ...this.originalPath.slice(closestOriginalIndex)
                ];
                this.pathIndex = 0;
            }

            returnToOriginalPath() {
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.originalPath.length; i++) {
                    const distance = p5.Vector.dist(this.position, this.originalPath[i]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                this.currentPath = [...this.originalPath.slice(closestIndex)];
                this.pathIndex = 0;
            }

            recalculatePath(obstacles, allRobots = []) {
                this.originalPath = findPath(this.position, this.mission.end, obstacles, allRobots);
                this.currentPath = [...this.originalPath];
                this.pathIndex = 0;
                this.hasDeviated = false;
            }

            draw() {
                // Draw original path (faint dotted line)
                if (this.originalPath.length > 1) {
                    stroke(100, 100, 255, 80);
                    strokeWeight(1);
                    drawingContext.setLineDash([5, 5]);
                    noFill();
                    beginShape();
                    for (let i = 0; i < this.originalPath.length; i++) {
                        vertex(this.originalPath[i].x, this.originalPath[i].y);
                    }
                    endShape();
                    drawingContext.setLineDash([]);
                }

                // Draw traveled path (solid bright line)
                if (this.traveledPath.length > 1) {
                    stroke(0, 200, 0, 150);
                    strokeWeight(2);
                    noFill();
                    beginShape();
                    for (let i = 0; i < this.traveledPath.length; i++) {
                        vertex(this.traveledPath[i].x, this.traveledPath[i].y);
                    }
                    endShape();
                }

                // Draw current path (orange if deviating, blue if normal)
                if (this.currentPath.length > 1) {
                    if (this.hasDeviated) {
                        stroke(255, 165, 0, 150);
                        strokeWeight(2);
                    } else {
                        stroke(100, 100, 255, 150);
                        strokeWeight(2);
                    }
                    noFill();
                    beginShape();
                    vertex(this.position.x, this.position.y);
                    for (let i = this.pathIndex; i < this.currentPath.length; i++) {
                        vertex(this.currentPath[i].x, this.currentPath[i].y);
                    }
                    endShape();
                }

                // Draw collision detection radius when avoiding
                if (this.isAvoidingCollision) {
                    fill(255, 100, 100, 20);
                    noStroke();
                    ellipse(this.position.x, this.position.y, (this.radius + 30) * 2, (this.radius + 30) * 2);
                }

                // Draw the robot with different colors based on state
                if (this.isAvoidingCollision) {
                    fill(255, 100, 100);
                } else if (this.reachedDestination) {
                    fill(0, 255, 0);
                } else {
                    fill(0, 100, 255);
                }
                
                stroke(0, 50, 150);
                strokeWeight(2);
                ellipse(this.position.x, this.position.y, this.radius * 2, this.radius * 2);

                // Draw robot ID
                fill(255);
                textAlign(CENTER);
                textSize(10);
                text(this.id, this.position.x, this.position.y + 3);

                // Draw direction indicator
                if (!this.reachedDestination && this.pathIndex < this.currentPath.length) {
                    const target = this.currentPath[this.pathIndex];
                    const direction = p5.Vector.sub(target, this.position);
                    if (direction.mag() > 0) {
                        direction.normalize();
                        direction.mult(this.radius + 6);
                        const arrowEnd = p5.Vector.add(this.position, direction);
                        
                        stroke(255, 255, 0);
                        strokeWeight(2);
                        line(this.position.x, this.position.y, arrowEnd.x, arrowEnd.y);
                    }
                }

                // Draw avoidance indicator
                if (this.isAvoidingCollision) {
                    fill(255, 0, 0);
                    textAlign(CENTER);
                    textSize(8);
                    text('AVOID', this.position.x, this.position.y - this.radius - 12);
                }
            }

            hasReachedDestination() {
                return this.reachedDestination;
            }

            getDistanceTraveled() {
                return this.totalDistance;
            }
        }

        // p5.js setup
        function setup() {
            const canvas = createCanvas(1000, 700);
            canvas.parent('canvas-container');
            background(240);
            
            // Initialize simulation elements
            obstacles = generateObstacles();
            pickupPoints = generatePickupPoints();
            dropoffPoints = generateDropoffPoints();
        }

        function draw() {
            background(240);

            // Draw no-go zone if active
            if (noGoZone.isActive) {
                fill(255, 0, 0, 50);
                stroke(255, 0, 0, 150);
                strokeWeight(2);
                rect(noGoZone.x, noGoZone.y, noGoZone.width, noGoZone.height);
                fill(255, 0, 0);
                textAlign(CENTER);
                textSize(12);
                text('NO-GO ZONE', noGoZone.x + noGoZone.width/2, noGoZone.y + noGoZone.height/2);
            }

            // Draw obstacles with shelving graphics
            obstacles.forEach(obstacle => {
                if (obstacle.dragging) {
                    fill(150, 150, 150);
                    stroke(100, 100, 100);
                } else {
                    fill(120, 120, 120);
                    stroke(80, 80, 80);
                }
                strokeWeight(2);
                rect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Draw shelving details
                fill(100, 100, 100);
                noStroke();
                // Horizontal shelves
                for (let i = 1; i < 3; i++) {
                    const shelfY = obstacle.y + (obstacle.height / 3) * i;
                    rect(obstacle.x + 3, shelfY - 1, obstacle.width - 6, 2);
                }
                // Vertical supports
                for (let i = 1; i < 3; i++) {
                    const supportX = obstacle.x + (obstacle.width / 3) * i;
                    rect(supportX - 1, obstacle.y + 3, 2, obstacle.height - 6);
                }
            });

            // Draw pickup points
            pickupPoints.forEach(point => {
                fill(0, 255, 0);
                stroke(0, 200, 0);
                strokeWeight(2);
                ellipse(point.x, point.y, 8, 8);
            });

            // Draw dropoff points
            dropoffPoints.forEach(point => {
                fill(0, 100, 255);
                stroke(0, 50, 200);
                strokeWeight(2);
                rect(point.x - 8, point.y - 8, 16, 16);
                fill(255);
                textAlign(CENTER);
                textSize(8);
                text('DROP', point.x, point.y + 2);
            });

            // Update and draw robots only when running
            if (simulationState === 'running') {
                if (!startTime) {
                    startTime = millis();
                }

                robots.forEach(robot => {
                    robot.update(robots, obstacles);
                    robot.draw();
                });

                // Check if all robots have reached their destination
                const allRobotsFinished = robots.every(robot => robot.hasReachedDestination());
                if (allRobotsFinished && robots.length > 0) {
                    simulationState = 'stopped';
                    updateStatus();
                    updateButtonStates();
                }
            }

            // Draw robots when paused or stopped (for visualization)
            if ((simulationState === 'paused' || simulationState === 'stopped') && robots.length > 0) {
                robots.forEach(robot => {
                    robot.draw();
                });
            }

            // Draw instructions
            if (simulationState === 'running') {
                fill(0, 0, 0, 150);
                noStroke();
                rect(10, 10, 350, 100);
                fill(255);
                textAlign(LEFT);
                textSize(12);
                text('Drag inventory racks to optimize layout', 20, 30);
                text('Robots proactively avoid congested routes', 20, 45);
                text(`Active Robots: ${robots.length}/${MAX_ROBOTS}`, 20, 60);
                text('Green dots: Pickup points | Blue squares: Dropoff stations', 20, 75);
                text('Dotted lines: Original paths | Orange lines: Avoidance paths', 20, 90);
            }
        }

        // Mouse interaction for dragging obstacles
        function mousePressed() {
            if (simulationState === 'running' || simulationState === 'paused') {
                for (let i = 0; i < obstacles.length; i++) {
                    const obstacle = obstacles[i];
                    if (mouseX >= obstacle.x && mouseX <= obstacle.x + obstacle.width &&
                        mouseY >= obstacle.y && mouseY <= obstacle.y + obstacle.height) {
                        obstacle.dragging = true;
                        draggedObstacle.index = i;
                        draggedObstacle.offset.x = mouseX - obstacle.x;
                        draggedObstacle.offset.y = mouseY - obstacle.y;
                        break;
                    }
                }
            }
        }

        function mouseDragged() {
            if (draggedObstacle.index !== null) {
                const obstacle = obstacles[draggedObstacle.index];
                const newX = constrain(mouseX - draggedObstacle.offset.x, 0, width - obstacle.width);
                const newY = constrain(mouseY - draggedObstacle.offset.y, 0, height - obstacle.height);
                
                obstacle.x = newX;
                obstacle.y = newY;
                
                // Recalculate paths for all robots
                robots.forEach(robot => {
                    robot.recalculatePath(obstacles, robots);
                });
            }
        }

        function mouseReleased() {
            if (draggedObstacle.index !== null) {
                obstacles[draggedObstacle.index].dragging = false;
                draggedObstacle.index = null;
            }
        }

        // Control functions
        function addRobot() {
            if (robots.length >= MAX_ROBOTS) return;

            // Select random pickup and dropoff points
            const randomPickup = pickupPoints[Math.floor(Math.random() * pickupPoints.length)];
            const randomDropoff = dropoffPoints[Math.floor(Math.random() * dropoffPoints.length)];

            const newRobot = new Robot(nextRobotId, {
                start: randomPickup,
                end: randomDropoff
            }, robots);

            robots.push(newRobot);
            nextRobotId++;
            
            // Start simulation if it was stopped
            if (simulationState === 'stopped') {
                simulationState = 'running';
                startTime = millis();
            }
            
            updateStatus();
            updateButtonStates();
        }

        function togglePause() {
            if (simulationState === 'running') {
                simulationState = 'paused';
                pausedTime = millis();
            } else if (simulationState === 'paused') {
                simulationState = 'running';
                startTime += (millis() - pausedTime);
            }
            
            updateStatus();
            updateButtonStates();
        }

        function resetSimulation() {
            robots = [];
            simulationState = 'stopped';
            startTime = 0;
            pausedTime = 0;
            collisionAvoidances = 0;
            pathDeviations = 0;
            nextRobotId = 1;
            
            // Reset obstacles to original positions
            obstacles = generateObstacles();
            
            updateStatus();
            updateButtonStates();
        }

        function toggleNoGoZone() {
            noGoZone.isActive = !noGoZone.isActive;
            
            // Recalculate paths for all robots when no-go zone changes
            robots.forEach(robot => {
                robot.recalculatePath(obstacles, robots);
            });
        }

        function updateStatus() {
            const robotCount = document.getElementById('robotCount');
            const timeValue = document.getElementById('timeValue');
            const distanceValue = document.getElementById('distanceValue');
            const collisionValue = document.getElementById('collisionValue');
            const deviationValue = document.getElementById('deviationValue');
            const efficiencyValue = document.getElementById('efficiencyValue');
            const statusIndicator = document.getElementById('statusIndicator');

            robotCount.textContent = robots.length;

            if ((simulationState === 'running' || simulationState === 'paused') && robots.length > 0) {
                const elapsed = (millis() - startTime) / 1000;
                timeValue.textContent = elapsed.toFixed(1) + 's';
                const totalDistance = robots.reduce((sum, robot) => sum + robot.getDistanceTraveled(), 0);
                distanceValue.textContent = Math.round(totalDistance) + 'px';
            } else if (simulationState === 'stopped' && robots.length > 0) {
                const elapsed = (millis() - startTime) / 1000;
                timeValue.textContent = elapsed.toFixed(1) + 's';
                const totalDistance = robots.reduce((sum, robot) => sum + robot.getDistanceTraveled(), 0);
                distanceValue.textContent = Math.round(totalDistance) + 'px';
            } else {
                timeValue.textContent = '0s';
                distanceValue.textContent = '0px';
            }

            collisionValue.textContent = collisionAvoidances;
            deviationValue.textContent = pathDeviations;
            
            // Calculate efficiency score
            const avoidingRobots = robots.filter(robot => robot.isAvoidingCollision).length;
            const efficiency = Math.max(0, 100 - (avoidingRobots / Math.max(robots.length, 1)) * 60);
            efficiencyValue.textContent = Math.round(efficiency) + '%';

            // Update status indicator
            statusIndicator.textContent = simulationState.charAt(0).toUpperCase() + simulationState.slice(1);
            statusIndicator.className = `status-indicator status-${simulationState}`;
        }

        function updateButtonStates() {
            const addRobotBtn = document.getElementById('addRobotBtn');
            const pauseBtn = document.getElementById('pauseBtn');

            if (simulationState === 'running') {
                addRobotBtn.disabled = robots.length >= MAX_ROBOTS;
                addRobotBtn.textContent = `Add Robot (${robots.length}/${MAX_ROBOTS})`;
                pauseBtn.disabled = false;
                pauseBtn.textContent = 'Pause';
            } else if (simulationState === 'paused') {
                addRobotBtn.disabled = true;
                addRobotBtn.textContent = 'Add Robot (Paused)';
                pauseBtn.disabled = false;
                pauseBtn.textContent = 'Resume';
            } else if (simulationState === 'stopped') {
                addRobotBtn.disabled = false;
                addRobotBtn.textContent = `Add Robot (${robots.length}/${MAX_ROBOTS})`;
                pauseBtn.disabled = robots.length === 0;
                pauseBtn.textContent = 'Pause';
            }
        }

        // Event listeners
        document.getElementById('addRobotBtn').addEventListener('click', addRobot);
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);
        document.getElementById('noGoZoneBtn').addEventListener('click', toggleNoGoZone);

        // Update metrics every frame
        setInterval(updateStatus, 100);
    </script>
</body>
</html>